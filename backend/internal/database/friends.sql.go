// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: friends.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createFriend = `-- name: CreateFriend :exec
INSERT INTO friends (user_id, friend_id, initiator_id)
values ($1, $2, $3)
`

type CreateFriendParams struct {
	UserID      uuid.UUID
	FriendID    uuid.UUID
	InitiatorID uuid.UUID
}

func (q *Queries) CreateFriend(ctx context.Context, arg CreateFriendParams) error {
	_, err := q.db.ExecContext(ctx, createFriend, arg.UserID, arg.FriendID, arg.InitiatorID)
	return err
}

const deleteFriend = `-- name: DeleteFriend :exec
DELETE FROM friends WHERE user_id = $1 AND friend_id = $2
`

type DeleteFriendParams struct {
	UserID   uuid.UUID
	FriendID uuid.UUID
}

func (q *Queries) DeleteFriend(ctx context.Context, arg DeleteFriendParams) error {
	_, err := q.db.ExecContext(ctx, deleteFriend, arg.UserID, arg.FriendID)
	return err
}

const getAllPendingRequests = `-- name: GetAllPendingRequests :many
SELECT user_id, friend_id, status, initiator_id, created_at, updated_at FROM friends WHERE status = 'pending'
`

func (q *Queries) GetAllPendingRequests(ctx context.Context) ([]Friend, error) {
	rows, err := q.db.QueryContext(ctx, getAllPendingRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Friend
	for rows.Next() {
		var i Friend
		if err := rows.Scan(
			&i.UserID,
			&i.FriendID,
			&i.Status,
			&i.InitiatorID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendRequests = `-- name: GetFriendRequests :many
SELECT 
    f.user_id, f.friend_id, f.status, f.initiator_id, f.created_at, f.updated_at,
    u.username as friend_username,
    up.avatar_url as friend_avatar_url
    -- future fields
FROM 
    friends f
JOIN 
    users u ON (
        CASE 
            WHEN f.user_id = $1 THEN f.friend_id
            ELSE f.user_id
        END = u.id
    )
LEFT JOIN
    user_preferences up ON up.user_id = u.id
WHERE 
    f.status = 'pending' AND (f.user_id = $1 OR f.friend_id = $1) AND initiator_id != $1
`

type GetFriendRequestsRow struct {
	UserID          uuid.UUID
	FriendID        uuid.UUID
	Status          string
	InitiatorID     uuid.UUID
	CreatedAt       time.Time
	UpdatedAt       time.Time
	FriendUsername  string
	FriendAvatarUrl sql.NullString
}

func (q *Queries) GetFriendRequests(ctx context.Context, userID uuid.UUID) ([]GetFriendRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFriendRequests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendRequestsRow
	for rows.Next() {
		var i GetFriendRequestsRow
		if err := rows.Scan(
			&i.UserID,
			&i.FriendID,
			&i.Status,
			&i.InitiatorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FriendUsername,
			&i.FriendAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendsList = `-- name: GetFriendsList :many
SELECT 
    f.user_id, f.friend_id, f.status, f.initiator_id, f.created_at, f.updated_at,
    u.username as friend_username,
    up.avatar_url as friend_avatar_url
    -- future fields
FROM 
    friends f
JOIN 
    users u ON (
        CASE 
            WHEN f.user_id = $1 THEN f.friend_id
            ELSE f.user_id
        END = u.id
    )
LEFT JOIN
    user_preferences up ON up.user_id = u.id
WHERE 
    f.status = 'accepted' AND (f.user_id = $1 OR f.friend_id = $1)
`

type GetFriendsListRow struct {
	UserID          uuid.UUID
	FriendID        uuid.UUID
	Status          string
	InitiatorID     uuid.UUID
	CreatedAt       time.Time
	UpdatedAt       time.Time
	FriendUsername  string
	FriendAvatarUrl sql.NullString
}

func (q *Queries) GetFriendsList(ctx context.Context, userID uuid.UUID) ([]GetFriendsListRow, error) {
	rows, err := q.db.QueryContext(ctx, getFriendsList, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendsListRow
	for rows.Next() {
		var i GetFriendsListRow
		if err := rows.Scan(
			&i.UserID,
			&i.FriendID,
			&i.Status,
			&i.InitiatorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FriendUsername,
			&i.FriendAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetFriendsTable = `-- name: ResetFriendsTable :exec
DELETE FROM friends
`

func (q *Queries) ResetFriendsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetFriendsTable)
	return err
}

const updateFriendStatus = `-- name: UpdateFriendStatus :exec
UPDATE friends SET status = $1 WHERE user_id = $2 AND friend_id = $3
`

type UpdateFriendStatusParams struct {
	Status   string
	UserID   uuid.UUID
	FriendID uuid.UUID
}

func (q *Queries) UpdateFriendStatus(ctx context.Context, arg UpdateFriendStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateFriendStatus, arg.Status, arg.UserID, arg.FriendID)
	return err
}
